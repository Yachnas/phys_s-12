<!DOCTYPE html>
<html lang="en">
<head>
    <title>PHYSCI 70: Intro to Digital Fabrication </title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css">
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js"></script>
    <link href="./style.css" rel="stylesheet">
</head>
<body>
    <div class="container-fluid bg-3 text-start">
        <br>
        <h3>Final Project</h3>
        <br>
            <div class="col-sm-8">
                <b><br>Introduction</b>
                <p>
                <br>
                    For my final project I wanted to make a simple controller that can be used to play a game.
                    The controller would be named "brick" because the breadboard is shaped like a brick.
                    You would physically interact with the controller to make things happen onscreen.
                </p>
            </div>
            <div class="col-sm-8">
                <b><br>Controller Build</b>
                <br>(Brick)
                <p>
                <br>
                    First I built the controller.
                    I wanted the controller to be able to sense motion, sound and button presses so I used the lis3dh accelerometer, the spw 2430 microphone,
                    2 buttons, 2 10k ohm resistors, an esp32 micocontroller, multicolored male wires and a breadboard. The red wires represent voltage connections,
                    the black wires represent ground connections, and the yellow wires represent analog/ digital data connections.
                    The images below show the completed controller. The first one shows the controller as it is turned off, and the second one showed it as it is plugged in.
                <br>
                <br>
                    The reason why I used the upper row for voltage and ground connections instead of just the first was to make sure my wiring was clean.
                    On my first try and building the board I wired the vin for the lis3dh, spw and 2 buttons onto the bottom row and the wires ended up getting really messy and it made
                    the board less compact. The second reason was because I noticed that when I quickly pressed the buttons the serial window would read no voltage from the
                    analog pins. I realized that my fingers were sometimes touching the ground and resistor wires and disrupting the circuit, so the next time I built the board I tried
                    to position the resistors and data connections farther from the button themselves.
                </p>
            </div>
            <div class = "col-lg">
                <br>
                <img src="img1.jpg" class="img-responsive margin" style="width:20%" alt="Sew">
                <img src="img2.jpg" class="img-responsive margin" style="width:20%" alt="Sew">
            </div>
            <div class="col-sm-8">
                <b><br>Controller Firmware</b>
                <br>Compression (Bricktalk compliant)
                <p>
                <br>
                    I worked on the controller firmware. I replaced the previous way I sent microcontroller data in old assignments
                    with a new system that reduced bandwidth usage by more than 50% (named bricktalk).
                    Instead of sending all sensor data invariably I tried to only send sensor data when it changed
                    since more than half of the time the x and y acceleration values as well as the microphone volume remained the same.
                    (the z value always fluctuates even when idle because of gravity, but sometimes it goes unchanged too)
                    Each bit in the first byte of the controller packet tells the laptop whether or not a specific piece of data is present.
                    I drew how the packet is organized below. For instance, if the microphone volume remains the same from the previous frame,
                    bit 7 is cleared in the header byte and the recipient will know not to continue to read 2 nonexistent bytes from its receive buffer.
                    I did not do anything like this for the buttons because their states are represented by a single bit each in the header byte and
                    I do not write any additional data for them.
                <br>
                </p>
            </div>
            <div class = "col-lg">
                <br>
                <img src="img3.png" class="img-responsive margin" style="width:50%" alt="Sew">
            </div>
            <div class="col-sm-8">
                <p>
                <br>
                    I want to finish the controller firmware and unity brick abstraction stuff
                    so that I can focus on the minigame and presentation video for the remaining days.
                    The brick firmware is below.
                </p>
                <br>
                    *I removed the angle brackets surrounding the initial include statements because they would make the header file names disappear on the website.
                    If you add them back in and enter your network information in the macros below the include statements it should work.
                <pre>
                    <br>
                        #include WiFi.h
                        #include WiFiUdp.h
                        #include Wire.h
                        #include SPI.h
                        #include Adafruit_LIS3DH.h
                        #include Adafruit_Sensor.h

                        #define ssid **
                        #define pw **
                        #define ip **
                        #define port **

                        enum id
                        {
                            idle,
                            conn,
                            sync
                        };

                        struct vector
                        {
                            int16_t x;
                            int16_t y;
                            int16_t z;
                        };

                        Adafruit_LIS3DH lis = Adafruit_LIS3DH(A1, 13, A5, 27);
                        WiFiUDP udp;
                        uint32_t t1;
                        uint32_t ct;
                        uint32_t to;
                        const uint8_t length = 16;
                        const uint8_t frame = 10;
                        const uint16_t disc = 5000;
                        enum id state;
                        uint8_t recv[length];
                        struct vector v1;
                        uint16_t s1;

                        void setup()
                        {
                            Serial.begin(115200);
                            while (!Serial)
                                yield();
                            WiFi.mode(WIFI_STA);
                            WiFi.disconnect();
                            WiFi.begin(ssid, pw);
                            while (WiFi.status() != WL_CONNECTED)
                                yield();
                            pinMode(A0, INPUT);
                            pinMode(A2, INPUT);
                            pinMode(A4, INPUT);
                            lis.begin(0x18);
                            state = idle;
                            logstate();
                        }

                        void loop()
                        {
                            uint32_t t2 = millis();
                            if (t2 - t1 >= frame)
                            {
                                const uint8_t status = WiFi.status();
                                switch (state)
                                {
                                    case idle:
                                    {
                                        bool* b = ibts();
                                        struct vector v = ilis();
                                        if (*b || *(b + 1) || sqrt(sq(v.x) + sq(v.y) + sq(v.z)) > 150)
                                        {
                                            udp.begin(port);
                                            state = conn;
                                            logstate();
                                        }
                                    }
                                    break;
                                    case conn:
                                    {
                                        ct += frame;
                                        if (status == WL_CONNECTED && ct < disc)
                                        {
                                            while (udp.parsePacket())
                                            {
                                                udp.read(recv, length);
                                                if (*recv == conn)
                                                {
                                                    udp.flush();
                                                    ct = 0;
                                                    state = sync;
                                                    logstate();
                                                    break;
                                                }
                                            }
                                            udp.beginPacket(ip, port);
                                            udp.write(udpid(conn));
                                            udp.endPacket();
                                        }
                                        else
                                        {
                                            udp.stop();
                                            ct = 0;
                                            state = idle;
                                            logstate();
                                        }
                                    }
                                    break;
                                    case sync:
                                    {
                                        if (status == WL_CONNECTED)
                                        {
                                            to += frame;
                                            while (udp.parsePacket())
                                            {
                                                udp.read(recv, length);
                                                if (*recv == sync)
                                                {
                                                    udp.flush();
                                                    to = 0;
                                                    break;
                                                }
                                            }
                                            if (to < disc)
                                            {
                                                bool* b = ibts();
                                                struct vector v2 = ilis();
                                                const uint32_t st = millis();
                                                uint16_t max = 0;
                                                uint16_t min = 1024;
                                                while (millis() - st < 20)
                                                {
                                                    uint16_t sample = analogRead(A4);
                                                    if (sample < 1024)
                                                    {
                                                        if (sample > max)
                                                            max = sample;
                                                        else if (sample < min)
                                                            min = sample;
                                                    }
                                                }
                                                uint16_t s2 = max - min;
                                                const bool rx = v1.x != v2.x;
                                                const bool ry = v1.y != v2.y;
                                                const bool rz = v1.z != v2.z;
                                                const bool rs = s1 == s2;
                                                uint8_t hdr = udpid(sync);
                                                bitWrite(hdr, 2, *b);
                                                bitWrite(hdr, 3, *(b + 1));
                                                bitWrite(hdr, 4, rx);
                                                bitWrite(hdr, 5, ry);
                                                bitWrite(hdr, 6, rz);
                                                bitWrite(hdr, 7, rs);
                                                udp.beginPacket(ip, port);
                                                udp.write(hdr);
                                                if (rx)
                                                    udpn(v2.x);
                                                if (ry)
                                                    udpn(v2.y);
                                                if (rz)
                                                    udpn(v2.z);
                                                if (rs)
                                                    udpn(s2);
                                                udp.endPacket();
                                                v1 = v2;
                                                s1 = s2;
                                                break;
                                            }
                                        }
                                        to = 0;
                                        udp.stop();
                                        state = idle;
                                        logstate();
                                        break;
                                    }
                                }
                                t1 = t2;
                            }
                        }

                        bool* ibts()
                        {
                            static bool bts[2];
                            bts[0] = digitalRead(A0);
                            bts[1] = digitalRead(A2);
                            return bts;
                        }

                        struct vector ilis()
                        {
                            const uint8_t n = 10;
                            const int16_t sn = 300;
                            struct vector v;
                            int32_t x;
                            int32_t y;
                            int32_t z;
                            for (uint8_t i = 0; i < n; i++)
                            {
                                lis.read();
                                x += lis.x;
                                y += lis.y;
                                z += lis.z;
                            }
                            x /= n * sn;
                            y /= n * sn;
                            z /= n * sn;
                            v.x = x;
                            v.y = y;
                            v.z = z;
                            return v;
                        }

                        uint8_t udpid(uint8_t id)
                        {
                            uint8_t hdr = 0;
                            for (uint8_t i = 0; i < 2; i++)
                                bitWrite(hdr, i, bitRead(id, i));
                            return hdr;
                        }

                        void udpn(uint16_t n)
                        {
                            for (uint8_t i = 0; i < sizeof(uint16_t); i++)
                                udp.write((byte)(n >> (i * 8)));
                        }

                        void logstate()
                        {
                            Serial.println();
                            Serial.println(state);
                        }

                </pre>
                <p>
                <br>
                    Below is a video showing a simple console socket program reading the header byte bits and displaying them on the window.
                    Note that the website firmware will not work with the console socket program because I manually set the state to sync for debugging in the setup function call.
                    If you follow the instructions below it should work though.
                </p>
                <pre>
                lis.begin(0x18);

                state = idle;

                //change to this vvv

                lis.begin(0x18);
                udp.begin(port);
                state = sync;
                </pre>
                <p>
                I also included the code for the console socket program that displays the bitfield in the video.
                </p>
                <pre>
                <br>
                using System;
                using System.Net;
                using System.Net.Sockets;

                namespace fp_console
                {
                    class Program
                    {
                        const int length = 16;

                        private static Socket socket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
                        private static byte[] recv = new byte[length];
                        private static byte[] send = new byte[length];

                        static void Main(string[] args)
                        {
                            socket.Blocking = false;
                            socket.Bind(new IPEndPoint(IPAddress.Any, 47777));
                            if (!socket.IsBound)
                                return;
                            bool run = true;
                            while (run)
                            {
                                while (socket.Available > 0)
                                {
                                    if (socket.Receive(recv) > length)
                                        break;
                                    byte hdr = recv[0];
                                    Console.WriteLine("bt1: " + ((hdr >> 2) & 1));
                                    Console.WriteLine("bt2: " + ((hdr >> 3) & 1));
                                    Console.WriteLine("lisx: " + ((hdr >> 4) & 1));
                                    Console.WriteLine("lisy: " + ((hdr >> 5) & 1));
                                    Console.WriteLine("lisz: " + ((hdr >> 6) & 1));
                                    Console.WriteLine("spw: " + ((hdr >> 7) & 1));
                                }
                            }
                        }
                    }
                }

                </pre>
                <p>
                    A 1 (set bit) means the controller is sending that instance of data, while a 0 (cleared bit) means the controller has omitted that instance of data.
                    You can see the bits for bt1 (button 1) and bt2 (button 2) changing as I press and release the buttons on the controller.
                </p>
            </div>
            <div class = "col-lg">
                <br>
                <video controls style="width:60%; min-width:300px">
                    <source src="vid1.mov" type="video/mp4">
                </video>
            </div>
            <div class="col-sm-8">
                <b><br>Controller Firmware</b>
                <br>Cleanup
                <p>
                <br>
                    I took some time and cleaned up the controller firmware. The new controller firmware takes up less lines, and I think
                    it should run a little bit faster since I sped up the sync switch statement call. I think that this firmware
                    is what I will stick with for the remainder of the final project, so I am now going to focus on the unity stuff.
                <pre>
                    code here
                </pre>
                </p>
            </div>
    </div>
</body>
</html>